---
title: "Novel Methods for Characterizing Peaks from Direct Injection FT-MS Experiments"
author: "Robert M Flight"
date: "`r Sys.time()`"
commit: "`r substr(git2r::branch_target(git2r::head(git2r::repository())), 1, 8)`"
output: 
  redoc::redoc
---

## Introduction


## Methods

### Conversion of M/Z to Frequency

The data consists of profile mode M/Z spectra from multiple scans encoded as M/Z and intensity values for each scan. There is no information about the original frequency values available in either the `raw` files or the `mzML` files. However, the frequency values can be approximated by averaging the M/Z of adjacent points, and dividing the M/Z by the difference. A constant difference of adjacent frequency values is expected, and points that have frequency differences within a narrow range can be used to construct a linear model relating M/Z to frequency for individual scans based on the formula:

$$frequency = intercept + slope* \frac{1}{\sqrt{mz}} $$
A model is generated for each scan, and then a single model using the median values of the intercept and slope across scans is chosen, and applied to convert the M/Z values to frequency for all scans. A single model rather than scan specific models is used because this was found to maintain the relative ordering of the peaks in M/Z and frequency space. Integer values (for use with the IRanges R package) are generated by multiplying each frequency by 400 and rounding.

### Frequency Intervals

Two types of frequency intervals are used, sliding and tiled windows. The sliding windows are 10 points wide, offset by one point from each other. The tiled windows are one point wide, offset by one point from each other. 

### Interval Range Based Data

To enable interval arithmetic, the frequency points are converted to single width intervals by multiplying and rounding (a multiplier of 400 in this work) and storing them as IRanges objects from the IRanges Bioconductor package. The sliding and tiled windows are also converted to IRanges objects the same way.

### Peak Containing Intervals

To find intervals that containing data that is not just noise, the number of zero intensity and non-zero intensity frequency points in each sliding window are counted, and any sliding window with a non-zero count greater than or equal to the 99th percentile of non-zero counts is kept, and the remaining sliding windows are reduced, where overlapping sliding windows are merged together to create the initial peak regions.

Within each initial interval region, peaks in each scan are detected (see **Peak Finding**), and their centers binned by the tiled windows. Adjacent tiled windos with non-zero peak counts are merged together, and any zero peak count tiled windows split the initial region into multiple peak interval regions. These interval regions should contain a single **real** peak that was detected in one or more scans.

### Peak Detection and Centroided Values

On a single scan level, possible peaks are detected by simple bump-hunting for two increasing points followed by two decreasing points using the `find_peaks` function in the pracma package. These possible peaks are then characterized using a weighted parabolic fit of log-intensity to position (where position is either M/Z or frequency), and where the weights for each point are the relative log-intensity compared to the maximum log-intensity for the peak.

$$\ln{intensity} = intercept + a*position+b*position^2$$
From this weighted parabolic fit the center, intensity, integrated area and sum-of-square residuals can be extracted for the peak. These characteristics are equivalent to the centroided peak center and intensity.

### Scan to Scan Normalization

Scans are normalized to a single *median* scan based on the log-intensity ratios of a subset of peaks that are present in the 95th percentile of scans. 
